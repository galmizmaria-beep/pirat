<div id="FX_ROOT">

<style>
    /*
     * Стили для кнопок-ответов. Вы можете изменять их, чтобы подогнать под дизайн вашей игры.
    */
    .answer-button {
        padding: 12px 20px;         /* Внутренние отступы */
        margin-bottom: 10px;        /* Внешний отступ снизу */
        background-color: #0d47a1;  /* Темно-синий фон, морская тематика */
        color: white;               /* Белый цвет текста */
        border: 2px solid #bbdefb;  /* Светло-голубая рамка */
        border-radius: 12px;        /* Скругление углов */
        text-align: center;         /* Выравнивание текста по центру */
        cursor: pointer;            /* Курсор в виде руки */
        font-weight: bold;          /* Жирный шрифт */
        transition: background-color 0.3s, transform 0.1s; /* Плавные переходы */
        box-shadow: 0 4px 6px rgba(0,0,0,0.2); /* Тень для объема */
    }

    /* Стиль для кнопки при наведении */
    .answer-button:hover {
        background-color: #1565c0; /* Более светлый синий при наведении */
    }

    /* Стиль для кнопки при нажатии */
    .answer-button:active {
        transform: scale(0.98) translateY(2px); /* Эффект нажатия */
        box-shadow: 0 2px 3px rgba(0,0,0,0.2);
    }

    /*
     * Контейнер для ответов внутри модального окна. 
     * Использует Flexbox для расположения кнопок в столбик.
    */
    .answers-container {
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {

    // ===================================================================================
    // 1. КОНФИГУРАЦИЯ ИГРЫ (Настраивается через метки в Genially)
    // ===================================================================================
    const gameConfig = {
        initialLives: 3,        // Начальное количество жизней
        questionTime: 20,       // Время на ответ (в секундах)
        bonusTime: 10,          // Бонусное время от сундука (в секундах)
        // Метки для элементов. Не меняйте их здесь, а присваивайте объектам в Genially.
        labels: {
            ship: 'ship',
            cannonball: 'cannonball',
            lifeIcon: 'life_icon',
            timerDisplay: 'timer_display',
            questionWindow: 'question_window',
            questionText: 'question_text',
            correctAnswer: 'correct_answer',
            wrongAnswer: 'wrong_answer',
            chestWindow: 'chest_window',
            mineWindow: 'mine_window',
            winScreen: 'win_screen',
            loseScreen: 'lose_screen',
            restartButton: 'restart_button',
            gameBoard: 'game_board', // Добавлена метка для игрового поля
            // Звуки
            fireSound: 'fire_sound',
            explosionSound: 'explosion_sound',
            correctSound: 'correct_sound',
            wrongSound: 'wrong_sound',
            chestSound: 'chest_sound',
            mineSound: 'mine_sound',
            winSound: 'win_sound',
            loseSound: 'lose_sound'
        }
    };

    // ===================================================================================
    // 2. ИГРОВОЕ СОСТОЯНИЕ (Не трогать)
    // ===================================================================================
    const gameState = {
        currentLives: gameConfig.initialLives,
        currentTimePerQuestion: gameConfig.questionTime,
        availableCellIds: [],
        isActionInProgress: false,
        timerInterval: null
    };

    // ===================================================================================
    // 3. ПОИСК ЭЛЕМЕНТОВ НА СЛАЙДЕ (Не трогать)
    // ===================================================================================
    const elements = {};

    function findElement(label) {
        // Ищем внутри корневого элемента игры для лучшей изоляции
        const root = document.getElementById('genially-view-slide-container');
        return root ? root.querySelector(`[data-genially-object-id][aria-label~="${label}"]`) : null;
    }

    function findElements(label) {
        const root = document.getElementById('genially-view-slide-container');
        return root ? root.querySelectorAll(`[data-genially-object-id][aria-label~="${label}"]`) : [];
    }
    
    // ===================================================================================
    // 4. ЛОГИКА ИГРЫ (Не трогать)
    // ===================================================================================

    function initGame() {
        console.log("Sea Battle Game Initializing...");

        // Находим все основные элементы
        for (const key in gameConfig.labels) {
            elements[key] = findElement(gameConfig.labels[key]);
        }
        elements.lifeIcons = Array.from(findElements(gameConfig.labels.lifeIcon));

        // Находим все игровые клетки (cell1, cell2, ..., 9)
        elements.cells = {};
        for (let i = 1; i <= 9; i++) {
            const cellId = `cell${i}`;
            const cellElement = findElement(cellId);
            if (cellElement) {
                elements.cells[cellId] = {
                    element: cellElement,
                    crater: findElement(`crater${i}`),
                    explosion: findElement(`explosion${i}`),
                    content: findElement(`content${i}`), // иконка сундука или меча
                    type: findElement(`type_${cellId}`) // элемент с типом (chest/mine)
                };
                gameState.availableCellIds.push(cellId);
            }
        }
        
        // Настройка конфигурации из Genially (если есть)
        const configLives = findElement('config_lives');
        if (configLives) gameConfig.initialLives = parseInt(configLives.innerText, 10) || 3;
        const configTime = findElement('config_time');
        if (configTime) gameConfig.questionTime = parseInt(configTime.innerText, 10) || 20;
        const configBonus = findElement('config_bonus');
        if (configBonus) gameConfig.bonusTime = parseInt(configBonus.innerText, 10) || 10;

        gameState.currentLives = gameConfig.initialLives;
        gameState.currentTimePerQuestion = gameConfig.questionTime;

        // Скрываем все, что не должно быть видно вначале
        hide(elements.cannonball, elements.questionWindow, elements.chestWindow, elements.mineWindow, elements.winScreen, elements.loseScreen, elements.timerDisplay);
        Object.values(elements.cells).forEach(cell => {
            if (cell.crater) hide(cell.crater);
            if (cell.explosion) hide(cell.explosion);
            if (cell.content) hide(cell.content);
        });

        // Настраиваем слушатели
        if (elements.ship) {
            elements.ship.style.cursor = 'pointer';
            elements.ship.addEventListener('click', fireCannon);
        }
        if (elements.restartButton) {
            elements.restartButton.style.cursor = 'pointer';
            elements.restartButton.addEventListener('click', () => window.location.reload());
        }

        updateLivesDisplay();
        console.log("Game Ready! Lives: " + gameState.currentLives);
    }

    function fireCannon() {
        if (gameState.isActionInProgress || gameState.availableCellIds.length === 0) return;
        gameState.isActionInProgress = true;
        
        playSound(elements.fireSound);

        const randomIndex = Math.floor(Math.random() * gameState.availableCellIds.length);
        const targetCellId = gameState.availableCellIds[randomIndex];
        const targetCell = elements.cells[targetCellId];
        
        show(elements.cannonball);
        elements.cannonball.style.transition = 'all 1s cubic-bezier(0.25, 0.5, 0.5, 1)';
        elements.cannonball.style.left = targetCell.element.style.left;
        elements.cannonball.style.top = targetCell.element.style.top;
        
        setTimeout(() => {
            hide(elements.cannonball);
            elements.cannonball.style.transition = 'none';
            // Не обязательно возвращать ядро, т.к. его начальные координаты берутся из DOM
            handleHit(targetCellId);
        }, 1000);
    }
    
    function handleHit(cellId) {
        const cell = elements.cells[cellId];
        playSound(elements.explosionSound);

        if(cell.explosion) show(cell.explosion);

        setTimeout(() => {
            if(cell.explosion) hide(cell.explosion);
            if(cell.element) hide(cell.element);
            if(cell.crater) show(cell.crater);
            
            gameState.availableCellIds = gameState.availableCellIds.filter(id => id !== cellId);
            
            if (cell.type) {
                const specialType = cell.type.getAttribute('aria-label');
                if (specialType.includes('chest')) {
                    triggerChestBonus(cell);
                } else if (specialType.includes('mine')) {
                    triggerMinePenalty(cell);
                } else {
                     showQuestion(cellId);
                }
            } else {
                 showQuestion(cellId);
            }

        }, 500); // Время анимации взрыва
    }

    function showQuestion(cellId) {
        const questionGroup = findElement(`q_${cellId}`);
        if (!questionGroup) {
            console.error(`Question group for ${cellId} not found!`);
            endTurn();
            return;
        }

        const questionText = questionGroup.querySelector(`[aria-label~="${gameConfig.labels.questionText}"]`);
        const correctAnswer = questionGroup.querySelector(`[aria-label~="${gameConfig.labels.correctAnswer}"]`);
        const wrongAnswers = Array.from(questionGroup.querySelectorAll(`[aria-label~="${gameConfig.labels.wrongAnswer}"]`));
        
        elements.questionWindow.querySelector(`[aria-label~="${gameConfig.labels.questionText}"]`).innerHTML = questionText.innerHTML;
        
        const answersContainer = elements.questionWindow.querySelector('.answers-container');
        if (!answersContainer) {
            console.error("'.answers-container' not found inside 'question_window'");
            endTurn();
            return;
        }
        answersContainer.innerHTML = '';

        const allAnswers = [correctAnswer, ...wrongAnswers].filter(Boolean).sort(() => Math.random() - 0.5);

        allAnswers.forEach(answerEl => {
            const button = document.createElement('div');
            button.className = 'answer-button';
            button.innerHTML = answerEl.innerHTML;
            
            if (answerEl.getAttribute('aria-label').includes(gameConfig.labels.correctAnswer)) {
                button.addEventListener('click', handleCorrectAnswer, { once: true });
            } else {
                button.addEventListener('click', handleWrongAnswer, { once: true });
            }
            answersContainer.appendChild(button);
        });
        
        show(elements.questionWindow);
        startTimer();
    }
    
    function handleCorrectAnswer() {
        stopTimer();
        playSound(elements.correctSound);
        hide(elements.questionWindow);
        endTurn();
    }

    function handleWrongAnswer() {
        stopTimer();
        playSound(elements.wrongSound);
        hide(elements.questionWindow);
        loseLife();
        endTurn();
    }
    
    function triggerChestBonus(cell) {
        if(cell.content) show(cell.content);
        playSound(elements.chestSound);
        gameState.currentTimePerQuestion += gameConfig.bonusTime;
        show(elements.chestWindow);
        setTimeout(() => {
            hide(elements.chestWindow);
            endTurn();
        }, 2000);
    }

    function triggerMinePenalty(cell) {
        if(cell.content) show(cell.content);
        playSound(elements.mineSound);
        show(elements.mineWindow);
        setTimeout(() => {
            hide(elements.mineWindow);
            loseLife();
            endTurn();
        }, 2000);
    }
    
    function loseLife() {
        gameState.currentLives--;
        updateLivesDisplay();
    }
    
    function updateLivesDisplay() {
        elements.lifeIcons.forEach((icon, index) => {
            if (index < gameState.currentLives) {
                show(icon);
            } else {
                hide(icon);
            }
        });
    }

    function endTurn() {
        if (gameState.currentLives <= 0) {
            gameOver(false); // Поражение
            return;
        }

        if (gameState.availableCellIds.length === 0) {
            gameOver(true); // Победа
            return;
        }
        
        gameState.isActionInProgress = false; // Разрешаем следующий ход
    }
    
    function gameOver(isWin) {
        gameState.isActionInProgress = true;
        const allGameElements = [elements.ship, elements.gameBoard, elements.questionWindow, elements.chestWindow, elements.mineWindow, ...elements.lifeIcons];
        hide(...allGameElements.filter(Boolean));

        if (isWin) {
            show(elements.winScreen);
            playSound(elements.winSound);
        } else {
            show(elements.loseScreen);
            playSound(elements.loseSound);
        }
    }

    function startTimer() {
        let timeLeft = gameState.currentTimePerQuestion;
        show(elements.timerDisplay);
        if(elements.timerDisplay) elements.timerDisplay.innerText = timeLeft;

        gameState.timerInterval = setInterval(() => {
            timeLeft--;
            if(elements.timerDisplay) elements.timerDisplay.innerText = timeLeft;
            if (timeLeft <= 0) {
                handleWrongAnswer(); // Время вышло = неверный ответ
            }
        }, 1000);
    }

    function stopTimer() {
        clearInterval(gameState.timerInterval);
        hide(elements.timerDisplay);
    }

    // Вспомогательные функции
    function show(...els) { els.forEach(el => el && (el.style.visibility = 'visible')); }
    function hide(...els) { els.forEach(el => el && (el.style.visibility = 'hidden')); }
    function playSound(el) { if (el && typeof el.play === 'function') el.play(); }

    // Запуск игры
    // Небольшая задержка, чтобы Genially успел отрендерить все элементы
    setTimeout(initGame, 300);
});
</script>

</div>
